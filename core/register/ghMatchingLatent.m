function [g, h] = ghMatchingLatent(model, mu, f, c, gmu, w, varargin)
%__________________________________________________________________________
% 
% Compute gradient/hessian of the **negative** log-likelihood with respect 
% to latent parameters in the principal subspace.
% 
% -------------------------------------------------------------------------
%
% FORMAT [(g), (h)] = ghMatchingLatent(model, mu, f, c, gmu, w, ...)
%
% REQUIRED
% --------
% model - Structure with fields:
%           * 'name'    : 'normal', 'laplace', 'bernoulli' or 'categorical'
%           * ('sigma2'): Normal variance  [1]
%           * ('b')     : Laplace variance [1]
% mu    - (Reconstructed) template image ([nx ny nz nc])
% f     - Observed image pushed into template space ([nx ny nz nc])
% c     - Pushed voxel count ([nx ny nz nc])
% gmu   - Template spatial gradients.
% w     - Principal subspace
%
%  KEYWORD ARGUMENTS
% ------------------
% bb      - Bounding box (if different between template and pushed image)
% hessian - Only compute hessian (not gradient)
% loop    - How to split: 'none', 'slice' [default: auto]
% par     - Parallelise: false/true/number of workers [default: auto]
% 
% OUTPUT
% ------
% g     - First derivatives w.r.t. latent PC parameters ([nq])
% h     - Second derivatives w.r.t. latent PC parameters ([nq nq])
%
%__________________________________________________________________________

    % --- Parse inputs
    p = inputParser;
    p.FunctionName = 'ghMatchingLatent';
    p.addRequired('model',  @(X) isstruct(X) && isfield(X, 'name'));
    p.addRequired('mu',     @checkarray);
    p.addRequired('f',      @checkarray);
    p.addRequired('c',      @checkarray);
    p.addRequired('gmu',    @checkarray);
    p.addRequired('w',      @checkarray);
    p.addParameter('bb',       struct,  @isstruct);
    p.addParameter('hessian',  false,   @islogical);
    p.addParameter('loop',     '',      @ischar);
    p.addParameter('par',      true,    @isscalar);
    p.addParameter('output',   []);
    p.addParameter('debug',    false,   @isscalar);
    p.parse(model, mu, f, c, gmu, w, varargin{:});
    loop    = p.Results.loop;
    par     = p.Results.par;
    output  = p.Results.output;
    debug   = p.Results.debug;
    bb  = p.Results.bb;
    hessian  = p.Results.hessian;
    
    if p.Results.debug, fprintf('* ghMatchingLatent\n'); end;
    
    % --- Optimise parallelisation and splitting schemes
    [par, loop] = autoParLoop(par, loop, isa(w, 'file_array'), size(w,3));
    
    % --- Default bounding box
    dim = [size(mu) 1];
    if ~isfield(bb, 'x')
        bb.x = 1:dim(1);
    end
    if ~isfield(bb, 'y')
        bb.y = 1:dim(2);
    end
    if ~isfield(bb, 'z')
        bb.z = 1:dim(3);
    end

    % --- Allocate arrays for grad and hessian
    do_gradient = ~hessian;
    do_hessian = nargout > 1 || hessian;
    nk  = size(w,5);
    if do_gradient
        g = zeros([nk 1], 'double');
    end
    if do_hessian
        h = zeros(nk, 'double');
    end

    % --- If loop on slices
    if strcmpi(loop, 'slice')
        nz = length(bb.z);
        if debug
            if par
                fprintf('  - Parallelise on slices\n')
            else
                fprintf('  - Serialise on slices\n')
            end
        end
        % Parfor has stupid rules:
        % 1) it loads all slices in memory at once, so file_array must be
        %    sliced with a subfunction to avoid memory explosion.
        % 2) it only sends subarrays to the workers if they specificaly
        %    appear in the form a(:,:,z,:) directly in the loop body 
        %    (we cannot use stored offsets).
        % This forces me to write a different loop for all different cases
        % of "on memory" vs "file array".
        fa_mu  = isa(mu,  'file_array');
        fa_f   = isa(f,   'file_array');
        fa_gmu = isa(gmu, 'file_array');
        fa_w   = isa(w,   'file_array');
        % ------------------------
        %   GRADIENT AND HESSIAN
        % ------------------------
        if do_hessian && do_gradient
            if ~par
                for z=1:nz
                    [g1, h1] = onMemory(model, ...
                        mu(bb.x,bb.y,bb.z(1)+z-1,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(bb.x,bb.y,bb.z(1)+z-1,:,:), ...
                        w(bb.x,bb.y,bb.z(1)+z-1,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif  fa_mu &&  fa_f &&  fa_gmu &&  fa_w
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        slicevol(mu, {bb.x,bb.y,bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x,bb.y,bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x,bb.y,bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif  fa_mu &&  fa_f &&  fa_gmu && ~fa_w
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif  fa_mu &&  fa_f && ~fa_gmu &&  fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        slievol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif  fa_mu && ~fa_f &&  fa_gmu &&  fa_w
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif ~fa_mu &&  fa_f &&  fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slicevol(fz, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif  fa_mu &&  fa_f && ~fa_gmu && ~fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif  fa_mu && ~fa_f &&  fa_gmu && ~fa_w
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif ~fa_mu &&  fa_f &&  fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slice(f, z, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif  fa_mu && ~fa_f && ~fa_gmu &&  fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif ~fa_mu &&  fa_f && ~fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif ~fa_mu && ~fa_f &&  fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif  fa_mu && ~fa_f && ~fa_gmu && ~fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif ~fa_mu &&  fa_f && ~fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif ~fa_mu && ~fa_f &&  fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            elseif ~fa_mu && ~fa_f && ~fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            else % ~fa_mu && ~fa_f && ~fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    [g1, h1] = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                    h = h + h1;
                end
            end
        % ----------------
        %   HESSIAN ONLY
        % ----------------
        elseif do_hessian
            if ~par
                for z=1:nz
                    h1 = onMemory(model, ...
                        mu(bb.x,bb.y,bb.z(1)+z-1,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(bb.x,bb.y,bb.z(1)+z-1,:,:), ...
                        w(bb.x,bb.y,bb.z(1)+z-1,:,:), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif  fa_mu &&  fa_f &&  fa_gmu &&  fa_w
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        slicevol(mu, {bb.x,bb.y,bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x,bb.y,bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x,bb.y,bb.z(1)+z-1}), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif  fa_mu &&  fa_f &&  fa_gmu && ~fa_w
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif  fa_mu &&  fa_f && ~fa_gmu &&  fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        slievol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif  fa_mu && ~fa_f &&  fa_gmu &&  fa_w
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif ~fa_mu &&  fa_f &&  fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slicevol(fz, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif  fa_mu &&  fa_f && ~fa_gmu && ~fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        w(:,:,z,:,:), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif  fa_mu && ~fa_f &&  fa_gmu && ~fa_w
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif ~fa_mu &&  fa_f &&  fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slice(f, z, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif  fa_mu && ~fa_f && ~fa_gmu &&  fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif ~fa_mu &&  fa_f && ~fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif ~fa_mu && ~fa_f &&  fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif  fa_mu && ~fa_f && ~fa_gmu && ~fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif ~fa_mu &&  fa_f && ~fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        w(:,:,z,:,:), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif ~fa_mu && ~fa_f &&  fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            elseif ~fa_mu && ~fa_f && ~fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            else % ~fa_mu && ~fa_f && ~fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    h1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        w(:,:,z,:,:), ...
                        'hessian',  true, ...
                        'loop',     'none', ...
                        'par',      false);
                    h = h + h1;
                end
            end
        % -----------------
        %   GRADIENT ONLY
        % -----------------
        else % do_gradient
            if ~par
                for z=1:nz
                    g1 = onMemory(model, ...
                        mu(bb.x,bb.y,bb.z(1)+z-1,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(bb.x,bb.y,bb.z(1)+z-1,:,:), ...
                        w(bb.x,bb.y,bb.z(1)+z-1,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif  fa_mu &&  fa_f &&  fa_gmu &&  fa_w
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        slicevol(mu, {bb.x,bb.y,bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x,bb.y,bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x,bb.y,bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif  fa_mu &&  fa_f &&  fa_gmu && ~fa_w
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                   g1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif  fa_mu &&  fa_f && ~fa_gmu &&  fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        slievol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif  fa_mu && ~fa_f &&  fa_gmu &&  fa_w
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif ~fa_mu &&  fa_f &&  fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slicevol(fz, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif  fa_mu &&  fa_f && ~fa_gmu && ~fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif  fa_mu && ~fa_f &&  fa_gmu && ~fa_w
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif ~fa_mu &&  fa_f &&  fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slice(f, z, 3), slicevol(c, z, 3), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif  fa_mu && ~fa_f && ~fa_gmu &&  fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif ~fa_mu &&  fa_f && ~fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif ~fa_mu && ~fa_f &&  fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif  fa_mu && ~fa_f && ~fa_gmu && ~fa_w
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        slicevol(mu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif ~fa_mu &&  fa_f && ~fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        slicevol(f, z, 3), slicevol(c, z, 3), ...
                        gmu(:,:,z,:,:), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif ~fa_mu && ~fa_f &&  fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        slicevol(gmu, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            elseif ~fa_mu && ~fa_f && ~fa_gmu &&  fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        slicevol(w, {bb.x, bb.y, bb.z(1)+z-1}), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            else % ~fa_mu && ~fa_f && ~fa_gmu && ~fa_w
                mu  = mu(bb.x,bb.y,bb.z,:);
                gmu = gmu(bb.x,bb.y,bb.z,:,:);
                w   = w(bb.x,bb.y,bb.z,:,:);
                parfor (z=1:nz, par)
                    g1 = onMemory(model, ...
                        mu(:,:,z,:), ...
                        f(:,:,z,:), c(:,:,z), ...
                        gmu(:,:,z,:,:), ...
                        w(:,:,z,:,:), ...
                        'loop',     'none', ...
                        'par',      false);
                    g = g + g1;
                end
            end
        end 
    % --- No loop
    else
        if debug
            fprintf('  - No loop\n')
        end
        mu  = mu(bb.x,bb.y,bb.z,:);
        gmu = gmu(bb.x,bb.y,bb.z,:,:);
        w   = w(bb.x,bb.y,bb.z,:,:);
        if do_hessian && do_gradient
            [g, h] = onMemory(model, mu, f, c, gmu, w, ...
                'loop',     loop, ...
                'par',      par, ...
                'debug',    debug);
        elseif do_hessian
            h = onMemory(model, mu, f, c, gmu, w, ...
                'hessian',  true, ...
                'loop',     loop, ...
                'par',      par, ...
                'debug',    debug);
        else % do_gradient
            g = onMemory(model, mu, f, c, gmu, w, ...
                'loop',     loop, ...
                'par',      par, ...
                'debug',    debug);
        end
    end

    if do_gradient
        g(~isfinite(g)) = 0;
    end
    if do_hessian
        % Insure symmetric hessian
        h = (h + h')/2;
        h(~isfinite(h)) = 0;
    end
    
    % --- Write on disk    
    if ~iscell(output)
        output = {output};
    end
    if numel(output) < 2
        output = [output {[]}];
    end
    if do_gradient
        if ~isempty(output{1})
            g = saveOnDisk(output{1}, g, 'name', 'g');
        end
    end
    if do_hessian
        if do_gradient
            if ~isempty(output{2})
                h = saveOnDisk(output{2}, h, 'name', 'h');
            end
        else
            if ~isempty(output{1})
                h = saveOnDisk(output{1}, h, 'name', 'h');
            end
            g = [];
            [g, h] = deal(h, g);
        end
    end
end

function [g, h] = onMemory(model, mu, f, c, gmu, w, varargin)


    % --- Multiply PCs with template gradients
    w = -pointwise(single(numeric(gmu)), single(numeric(w)));
    clear gmu
    % => size(w) = [nx ny nz nclasses nlatent]

    % --- Compute grad/hess w.r.t. the complete velocity
    % (fast version that does not perform grad multiplication)
    hessian = find(strcmpi('hessian', varargin));
    hessian = ~isempty(hessian) && varargin{hessian+1};
    if nargout == 1
        if hessian
            [h, htype] = ghMatchingVel(model, mu, f, c, varargin{:});
        else
            g = ghMatchingVel(model, mu, f, c, varargin{:});
        end
    else
        [g, h, htype] = ghMatchingVel(model, mu, f, c, varargin{:});
    end
    clear mu f c

    % --- Compute grad/hess w.r.t. the latent (low-dim) coordinates
    if nargout == 1
        if hessian
            h = vel2latGradHessMatching(w, [], h, htype);
        else
            g = vel2latGradHessMatching(w, g);
        end
    else
        [g, h] = vel2latGradHessMatching(w, g, h, htype);
    end
    clear w

    if hessian
        g = [];
        [g, h] = deal(h, g);
    end
end
    
function [g, h] = vel2latGradHessMatching(w, g, h1, htype)
% FORMAT [(g), (h)] = vel2latGradHessMatching(w, g, h, htype)
% w     - Shape subspace basis (pre-multiplied by the template gradients)
% g     - Gradient w.r.t. the full velocity
% h     - Hessian w.r.t. the full velocity
% htype - Type of the hessian approximation w.r.t. classes:
%         'diagonal' or 'symtensor'
%
% Apply the chain rule to convert Grad/Hess w.r.t. the full velocity to
% Grad/Hes w.r.t. the latent coordinates.

    % --- Dim info
    dim         = [size(w) 1 1 1];
    dim         = dim(1:5);
    dim_lattice = dim(1:3);
    dim_classes = dim(4);   % Number of classes (Pre-multiplied W(xi,k) * -Gmu(xi))
    dim_latent  = dim(5);
    
    % --- Default arguments
    do_hessian  = nargin > 2;
    do_gradient = ~isempty(g);
    if do_hessian && nargin < 4
        % Try to guess htype
        if issame(size(h1, 4), dim_latent)
            htype = 'diagonal';
        else
            htype = 'symtensor';
        end
    end
    
    % --- Gradient
    % G = w' * g1
    w = reshape(w, [], dim_latent); % Matrix form
    if do_gradient
        g = double(w' * g(:));
    end
    
    % --- Hessian
    if do_hessian
        h = zeros(dim_latent, 'double');
        switch htype
            case {'symtensor'}
                % H = sum_{j,k} [ w_j' * h1_{j,k} * w_k ]
                % ^ where j, k are classes/modalities
                ind = symIndices(size(h1, 4));
                w = reshape(w, [prod(dim_lattice) dim_classes dim_latent]);
                for j=1:dim_classes
                    for k=1:dim_classes
                        wk = reshape(w(:,k,:), [], dim_latent);
                        hjk = h1(:,:,:,ind(j, k));
                        % > h1_{j,k} * w_k
                        hjk = bsxfun(@times, hjk(:), wk);
                        clear wk
                        wj = reshape(w(:,j,:), [], dim_latent);
                        % > w_j' * h1_{j,k} * w_ka
                        h = h + double(wj' * hjk);
                        clear hjk wj
                    end
                end
            case {'diagonal'}
                % H = sum_k [ w_k' * h1_k * w_k ]
                % ^ where k is a class/modality
                w = reshape(w, [prod(dim_lattice) dim_classes dim_latent]);
                for k=1:dim_classes
                    wk = reshape(w(:,k,:), [], dim_latent);
                    hk = h1(:,:,:,k);
                    h = h + double(wk' * bsxfun(@times, hk(:), wk));
                    clear wk hk
                end
            otherwise
                error('Unknown hessian type.');
        end
    else
        h = [];
    end

    if do_hessian && ~do_gradient
        [g, h] = deal(h, g);
    end
    
end
